# 智能出题系统 - 技术文档

## 1. 技术栈详解

### 1.1 核心依赖

```python
streamlit==1.31.1          # Web UI 框架
langgraph>=0.0.30          # 智能体编排框架
langchain-google-genai     # Google Gemini LLM 集成
langchain-openai           # OpenAI LLM 集成
pandas>=2.0.0              # 数据处理
scikit-learn>=1.3.0        # TF-IDF 向量化
openpyxl                   # Excel 文件读取
```

### 1.2 Python 版本
- **最低要求**: Python 3.10+
- **推荐版本**: Python 3.11

## 2. 核心模块技术实现

### 2.1 exam_factory.py - 知识检索层

#### 2.1.1 KnowledgeRetriever 类

**职责**: 知识库管理、母题检索、题型过滤

**核心方法实现**:

```python
class KnowledgeRetriever:
    def __init__(self, kb_path, history_path):
        """
        初始化检索器
        1. 加载知识库 (JSONL)
        2. 加载母题库 (Excel)
        3. 构建 TF-IDF 向量索引
        4. 加载知识点映射文件
        5. 构建反向索引 kb_path -> [question_indices]
        """
        
    def _get_question_type(self, row):
        """
        题型识别算法:
        - 判断题: 选项1=="正确" AND 选项2=="错误"
        - 多选题: 答案长度 > 1 且全为 ABCDE
        - 单选题: 默认
        """
        
    def _is_valid_example(self, row):
        """
        数据质量过滤:
        检查必需字段: 题干、选项1-2、答案、解析
        过滤 NaN 和空字符串
        """
        
    def get_examples_by_knowledge_point(self, kb_chunk, k=3, question_type=None):
        """
        知识点精准检索:
        1. 从映射文件查找 kb_path 对应的 question_indices
        2. 随机采样 k*5 个候选 (考虑过滤损耗)
        3. 应用题型过滤
        4. 应用数据质量过滤
        5. 返回前 k 个有效范例
        6. 如无映射则回退到 TF-IDF 检索
        """
```

**技术要点**:
- **映射文件**: `question_knowledge_mapping.json` 由 `map_questions_to_knowledge.py` 生成
- **过滤策略**: 候选数 = k × 5，确保过滤后仍有足够范例
- **回退机制**: 无映射时自动降级为 TF-IDF 相似度检索

#### 2.1.2 map_questions_to_knowledge.py - 映射生成

**算法流程**:
1. 加载 408 道母题 + 1712 条知识点
2. 对每道母题:
   - **策略1**: 精确匹配 - 母题的`考点`字段 ⊆ KB路径
   - **策略2**: 模糊匹配 - 归一化后的考点 ⊆ 归一化后的KB路径
   - **策略3**: TF-IDF 相似度 - 找最相似的 KB 条目
3. 保存映射关系 + 置信度 + 匹配方法

**技术难点**:
- **归一化**: 去除标点、空格、转小写
- **TF-IDF**: 联合考点+题干 vs. 路径+内容

### 2.2 exam_graph.py - 智能体编排层

#### 2.2.1 AgentState - 状态定义

```python
class AgentState(TypedDict):
    kb_chunk: dict            # 知识点切片
    examples: list            # 母题范例 (路由后填充)
    agent_name: str           # Router 决定的专家名称
    draft: dict               # 初稿 (Specialist/Finance 生成)
    final_json: dict          # 最终题目 (Writer 格式化)
    critic_result: dict       # Critic 验证结果
    retry_count: int          # 重试次数
    logs: list                # 日志记录
    tool_usage: dict          # 计算器调用记录 (Finance)
```

#### 2.2.2 节点实现详解

**Router Node**:
```python
def router_node(state, config):
    """
    1. 提取知识点路径和内容
    2. LLM 分析:
       - 金融相关度 (0-100)
       - 法律相关度 (0-100)
       - 掌握程度 (了解/熟悉/掌握)
    3. 决策逻辑:
       - finance_score > 60 → FinanceAgent
       - legal_score > 60 → LegalAgent
       - 否则 → GeneralAgent
    4. 返回: agent_name + routing_details
    """
```

**Specialist Node**:
```python
def specialist_node(state, config):
    """
    1. 获取 retriever 和 question_type (从 config)
    2. 调用 get_examples_by_knowledge_point() 获取母题
    3. 构建 Few-Shot Prompt:
       - 角色定义
       - 质量标准 (准确性40%、干扰项25%、相关性15%、场景化10%、格式10%)
       - 参考材料
       - 母题范例列表
       - 任务说明
    4. LLM 生成初稿
    5. parse_json_from_response() 解析
    6. 返回: draft + examples
    """
```

**Finance Node**:
```python
def finance_node(state, config):
    """
    Step 1: 照猫画虎 (优先)
      - 获取母题范例
      - 分析范例是否包含计算题 (检查关键词: 计算、公式、=、×等)
      
    Step 2: 计算器决策
      - Prompt 包含: "范例中{'包含' if... else '不包含'}计算题"
      - LLM 分析材料并决定工具+参数
      - 调用 RealEstateCalculator.tool_name(**params)
      
    Step 3: 生成题目
      - Prompt 包含:
        * 计算上下文 (工具、参数、结果)
        * 母题范例
        * 质量标准
      - LLM 生成初稿
      - 返回: draft + tool_usage + examples
    """
```

**Critic Node** ✅:
```python
def critic_node(state, config):
    """
    1. 提取 draft (题目、选项、答案、解析)
    2. 计算器验证 ✅ (增强):
       a) **参数提取**：从题目中提取具体数值（不能是描述性文字）
       b) **计算步骤分析**：理解计算器可能只是解决一个步骤
       c) 重新调用计算器验证
       d) 如果计算器结果是中间步骤，验证完整计算过程
    3. 两步验证:
       a) 答案验证:
          - 金融题: 使用计算结果验证（考虑多步计算）✅
          - 其他: LLM 推理验证
       b) 解析验证:
          - LLM 判断解析的逻辑性和清晰度
          - 如果涉及多步计算，检查是否说明了所有步骤 ✅
    4. 问题分类 ✅:
       - 答案错误 → issue_type = "major" (严重问题)
       - 解析不清 → issue_type = "minor" (轻微问题)
    5. 决策:
       - 答案正确 AND 解析有效 → 通过
       - 否则 → 需修复 + retry_count + 1
    6. 返回: critic_result (passed/issue_type/reason)
    """
```

**Fixer Node** ✅:
```python
def fixer_node(state, config):
    """
    1. 检查 retry_count
    2. 修复策略:
       - LLM 分析问题
       - 尝试修复 draft
    3. 返回: 修复后的 final_json
    4. 循环: 自动回到 Critic 重新验证 ✅
    注意: 无需手动重试，由 critical_decision() 统一管理
    """
```

**critical_decision()** - 智能决策函数 ✅:
```python
def critical_decision(state: AgentState):
    """
    根据 Critic 结果决定下一步路由：
    1. critic_result['passed'] == True → "pass" → END
    2. retry_count >= 3 → "self_heal" → END (自愈输出)
    3. issue_type == "major" → "reroute" → Router (重新路由)
    4. issue_type == "minor" → "fix" → Fixer (修复)
    """
```

**Router Node** - 重路由支持 ✅:
```python
def router_node(state: AgentState, config):
    """
    ... (原有路由逻辑)
    
    # 新增: 重路由状态清理
    if state.get('retry_count', 0) > 0:
        state_updates["draft"] = None
        state_updates["final_json"] = None
        state_updates["logs"].append("🔄 检测到重新路由")
    
    return state_updates
    """
```

#### 2.2.3 边连接配置 ✅

**Graph 构建**:
```python
# Critic 的智能决策
workflow.add_conditional_edges(
    "critic",
    critical_decision,
    {
        "pass": END,              # 通过 → 结束
        "fix": "fixer",          # 轻微问题 → Fixer
        "reroute": "router",     # 严重问题 → Router
        "self_heal": END          # 超限 → 自愈输出
    }
)

# Fixer 循环
workflow.add_edge("fixer", "critic")  # Fixer → Critic 重新验证
```

**parse_json_from_response()**:
```python
def parse_json_from_response(response):
    """
    健壮的 JSON 解析:
    1. 尝试直接 json.loads()
    2. 失败则提取 markdown 代码块中的 JSON
    3. 仍失败则提取大括号内容
    4. 返回 dict or 抛出异常
    """
```

**generate_content()**:
```python
def generate_content(model, prompt, api_key, base_url=None):
    """
    LLM 调用封装:
    - 支持 Google Gemini / OpenAI
    - 统一错误处理
    - 日志记录 finish_reason
    """
```

### 2.3 calculation_logic.py - 计算工具层

#### 2.3.1 RealEstateCalculator

**设计模式**: 静态工具类，所有方法为 `@staticmethod`

**工具函数列表** (16个):
```python
calculate_loan_amount()              # 贷款额度
calculate_provident_fund_loan()      # 公积金贷款
calculate_vat()                      # 增值税
calculate_deed_tax()                 # 契税
calculate_land_grant_fee_*()         # 土地出让金 (3种)
calculate_land_remaining_years()     # 土地剩余年限
calculate_house_age()                # 房龄
calculate_indoor_height()            # 室内净高
calculate_building_area()            # 建筑面积
calculate_efficiency_rate()          # 得房率
calculate_area_error_ratio()         # 面积误差比
calculate_price_diff_ratio()         # 价格差异比
calculate_plot_ratio()               # 容积率
calculate_green_rate()               # 绿化率
```

**技术要点**:
- 所有函数严格类型检查 (int/float)
- 返回格式统一 (保留小数位数)
- 异常处理友好 (返回错误信息)

### 2.4 app.py - UI层

#### 2.4.1 Streamlit 架构

**页面布局**:
```
侧边栏:
  ├── API 配置 (Key, Model, Base URL, Proxy)
  └── 章节选择 (多选/全选/仅计算类)

主区域:
  ├── 出题设置 (数量、难度、题型)
  ├── 开始出题按钮
  └── 生成状态展示 (st.status)
       ├── Router 决策
       ├── 照猫画虎范例 (st.expander)
       ├── 计算器调用详情 (st.expander)
       ├── 初稿内容 (st.expander)
       ├── Critic 评审 (st.expander)
       ├── Fixer 修复 (st.expander)
       └── 最终题目
```

**核心技术**:
- **缓存**: `@st.cache_resource` 缓存 KnowledgeRetriever
- **流式输出**: `graph_app.stream(inputs, config)` 遍历事件
- **动态渲染**: 根据 `node_name` 和 `state_update` 动态显示不同内容

#### 2.4.2 配置传递

**Config 结构**:
```python
config = {
    "configurable": {
        "model": model_name,           # Gemini/OpenAI/DeepSeek
        "api_key": api_key,             # API密钥
        "base_url": base_url,           # 可选（如 https://api.deepseek.com）
        "retriever": retriever,         # KnowledgeRetriever 实例
        "question_type": question_type, # 单选/多选/判断
        "generation_mode": generation_mode  # 灵活/严谨模式 ✅
    }
}
```

**传递路径**:
```
app.py 构建 config
      ↓
传递给 graph_app.stream()
      ↓
每个 node 通过 config['configurable'] 访问
```

## 3. 数据流技术实现

### 3.1 知识库加载

**bot_knowledge_base.jsonl**:
```json
{
  "完整路径": "第一篇 > 第一章 > 第一节 > ...",
  "掌握程度": "了解/熟悉/掌握",
  "核心内容": "知识点文本",
  "Bot专用切片": "格式化后的文本"
}
```

**加载代码**:
```python
with open(kb_path, 'r', encoding='utf-8') as f:
    for line in f:
        kb_data.append(json.loads(line))
```

### 3.2 母题库加载

**存量房买卖母卷ABCD.xls**:
```python
df = pd.read_excel(history_path)
# 关键列: 题干、选项1-5、正确答案、解析、考点、难度值
```

**TF-IDF 索引**:
```python
corpus = (df['题干'].astype(str) + " " + df['考点'].astype(str)).tolist()
vectorizer = TfidfVectorizer()
tfidf_matrix = vectorizer.fit_transform(corpus)
```

### 3.3 知识点映射加载

**question_knowledge_mapping.json**:
```json
{
  "0": {
    "题干": "...",
    "考点": "...",
    "matched_kb_path": "第一篇 > ...",
    "matched_kb_index": 123,
    "confidence": 0.85,
    "method": "tfidf_similarity"
  },
  ...
}
```

**反向索引构建**:
```python
kb_to_questions = {}  # kb_path -> [question_idx1, idx2, ...]
for q_idx, mapping_info in mapping.items():
    kb_path = mapping_info['matched_kb_path']
    kb_to_questions.setdefault(kb_path, []).append(int(q_idx))
```

## 4. 关键算法

### 4.1 题型识别算法

```python
def _get_question_type(row):
    # 判断题: 选项特征匹配
    if row['选项1'] == '正确' and row['选项2'] == '错误':
        return '判断题'
    
    # 多选题: 答案特征匹配
    answer = str(row['正确答案']).strip()
    if len(answer) > 1 and all(c in 'ABCDE' for c in answer):
        return '多选题'
    
    # 默认: 单选题
    return '单选题'
```

### 4.2 数据质量过滤算法

```python
def _is_valid_example(row):
    required_fields = ['题干', '选项1', '选项2', '正确答案', '解析']
    for field in required_fields:
        value = row.get(field)
        # 过滤 NaN
        if pd.isna(value):
            return False
        # 过滤空字符串
        if isinstance(value, str) and value.strip() == '':
            return False
    return True
```

### 4.3 计算题识别算法 (Finance Node)

```python
examples_have_calculations = False
for ex in examples:
    explanation = str(ex.get('解析', ''))
    # 关键词匹配
    keywords = ['计算', '公式', '=', '×', '÷', '%', '元', '平方米', '年']
    if any(keyword in explanation for keyword in keywords):
        examples_have_calculations = True
        break
```

## 5. 错误处理与容错

### 5.1 JSON 解析容错

**问题**: LLM 输出可能包含 markdown 代码块或多余文本

**解决方案**:
```python
def parse_json_from_response(response):
    # 尝试1: 直接解析
    try:
        return json.loads(response)
    except:
        pass
    
    # 尝试2: 提取 markdown 代码块
    pattern = r'```(?:json)?\s*(\{.*?\})\s*```'
    match = re.search(pattern, response, re.DOTALL)
    if match:
        return json.loads(match.group(1))
    
    # 尝试3: 提取大括号内容
    match = re.search(r'\{.*\}', response, re.DOTALL)
    if match:
        return json.loads(match.group(0))
    
    raise ValueError("无法解析 JSON")
```

### 5.2 反馈循环机制 ✅ (新增)

**Fixer → Critic 循环**:
```python
# Workflow 配置
workflow.add_edge("fixer", "critic")  # 修复后自动回到验证

# 执行流程
Critic (发现问题, issue_type='minor') 
  → critical_decision() 返回 "fix"
  → Fixer Node (修复题目)
  → 自动回到 Critic (重新验证)
  → 如果通过: critical_decision() 返回 "pass" → END
  → 如果仍有问题: retry_count + 1, 继续循环
```

**Critic → Router 重路由**:
```python
# Workflow 配置
workflow.add_conditional_edges(
    "critic",
    critical_decision,
    {"reroute": "router", ...}
)

# 执行流程
Critic (发现严重问题, issue_type='major')
  → critical_decision() 返回 "reroute"
  → Router Node (重新分析, 可能选择不同Agent)
  → 清理旧状态 (draft, final_json)
  → Specialist/Finance (重新生成)
  → Writer → Critic (重新验证)
```

**retry_count 管理**:
```python
# Critic 发现问题时
return {"retry_count": state['retry_count'] + 1}

# critical_decision 检查超限
if retry_count >= 3:
    return "self_heal"  # 触发自愈输出，避免无限循环
```

### 5.3 自愈机制 ✅

**触发条件**:
- Critic 验证失败
- retry_count < 3

**策略** ✅:
```python
# 由 critical_decision() 统一管理
if retry_count < 3:
    if issue_type == 'major':
        return "reroute"  # 严重问题 → Router
    else:
        return "fix"      # 轻微问题 → Fixer
else:
    return "self_heal"    # 超限 → 自愈输出
```

**Fixer 修复逻辑**:
```python
# Fixer 只负责修复，不管理重试逻辑
def fixer_node(state, config):
    # 分析问题
    feedback = state.get('critic_feedback')
    # 修复题目
    fixed_json = llm_fix(draft, feedback)
    return {"final_json": fixed_json}
    # 自动回到 Critic (由 workflow.add_edge("fixer", "critic") 实现)
```


### 5.4 计算器调用容错


```python
try:
    calc_result = func(**params)
except Exception as e:
    calc_result = f"Error: {str(e)}"
    # 继续执行，不阻断流程
```

## 6. 性能优化

### 6.1 缓存策略

```python
@st.cache_resource
def get_retriever():
    return KnowledgeRetriever(KB_PATH, HISTORY_PATH)
```

**效果**: 
- 避免每次刷新重新加载知识库
- 加载时间从 5 秒降至 0 秒 (缓存命中)

### 6.2 检索优化

**候选扩大策略**:
```python
# 过滤前: 取 k*5 个候选
top_candidates = similarities.argsort()[-(k*5):][::-1]

# 过滤: 题型 + 数据质量
for idx in top_candidates:
    if len(examples) >= k:
        break
    if valid and matches_type:
        examples.append(...)

# 过滤后: 返回 k 个
return examples
```

**效果**: 确保过滤后仍能获得足够范例

### 6.3 流式输出

```python
for event in graph_app.stream(inputs, config):
    for node_name, state_update in event.items():
        # 逐节点渲染 UI
        st.write(...)
```

**效果**: 避免用户长时间等待，提升体验

## 7. 安全性考虑

### 7.1 API Key 保护

```python
# 不在代码中硬编码
# 方式1: Streamlit 输入框 (用户输入)
# 方式2: 从配置文件读取
# 方式3: 从环境变量读取
```

### 7.2 LLM 输出验证

- **JSON 格式验证**: parse_json_from_response()
- **内容验证**: Critic Node
- **计算验证**: 重新调用计算器

### 7.3 文件路径安全

```python
# 使用绝对路径
KB_PATH = "bot_knowledge_base.jsonl"
HISTORY_PATH = "存量房买卖母卷ABCD.xls"
```

## 8. 部署说明

### 8.1 本地部署

```bash
# 1. 安装依赖
pip install -r requirements.txt

# 2. 准备数据文件
# - bot_knowledge_base.jsonl
# - 存量房买卖母卷ABCD.xls
# - question_knowledge_mapping.json (运行 map_questions_to_knowledge.py 生成)

# 3. 配置 API Key
# - 创建 填写您的Key.txt
# - 或在 UI 中输入

# 4. 启动应用
streamlit run app.py
```

### 8.2 生产环境注意事项

1. **API 限流**: 注意 LLM 调用频率限制
2. **并发控制**: Streamlit 默认单进程，高并发需配置
3. **日志管理**: 生产环境需配置日志输出
4. **错误监控**: 集成 Sentry 等监控工具

## 9. 调试与日志

### 9.1 日志级别

```python
# Debug 级别
print(f"DEBUG RAW CONTENT: {content}")

# Error 级别
print(f"Finance Planning Error: {e}")
```

### 9.2 UI 日志展示

```python
# 每个节点返回 logs
return {"logs": [f"👨‍💻 {agent_name}: 初稿已生成"]}

# UI 展示
for log in state_update['logs']:
    st.write(log)
```

## 10. 测试策略

### 10.1 单元测试

- **目标模块**: `calculation_logic.py`
- **测试方法**: `pytest`
- **覆盖率目标**: > 80%

### 10.2 集成测试

- **目标**: 端到端流程
- **测试场景**: 
  - 单选题生成
  - 计算题生成
  - 判断题生成
  - Critic 拒绝 + Fixer 修复

### 10.3 性能测试

- **工具**: `locust` 模拟并发
- **指标**: 
  - 响应时间
  - 成功率
  - 资源占用

## 11. 常见问题排查

### Q1: LLM 返回空
**排查**:
1. 检查 API Key
2. 检查网络连接
3. 检查 `finish_reason` 日志

### Q2: JSON 解析失败
**排查**:
1. 查看 `DEBUG RAW CONTENT` 日志
2. 检查 LLM 输出格式
3. 调整 prompt 明确要求 JSON

### Q3: 计算器调用失败
**排查**:
1. 检查参数类型 (是否为 int/float)
2. 检查参数完整性
3. 查看错误日志

### Q4: 母题范例为空
**排查**:
1. 检查 `question_knowledge_mapping.json` 是否存在
2. 检查知识点路径是否匹配
3. 查看题型过滤是否过于严格
